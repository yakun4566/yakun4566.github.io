<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="Netty编解码器如何使用">
<title>Netty编解码器如何使用</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />

</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Netty编解码器如何使用</h1>
<div class="title-right">
    <a href="https://yakun4566.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/yakun4566/yakun4566.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><blockquote>
<p>Netty 的编解码器，我们首先需要先明白什么是拆包/粘包。</p>
</blockquote>
<h1>拆包/粘包</h1>
<h2>现象演示</h2>
<p>首先我们需要知道什么是拆包/粘包现象。</p>
<p>假设客户端向服务端发送两个数据包，分别为 package1 和 package2，这个时候服务端接收到客户端的数据有可能有如下四种情况。</p>
<ul>
<li>情况 1 ：服务端正常接收 package1 和 package 2，这种属于正常情况。</li>
<li>情况 2：服务端只接收到了一个 package，由于 TCP 保证送达的特性，所以这个 package 包含了客户端发送的两个 package ，这种现象属于粘包现象。如果客户端和服务端没有对应的协议来明确 package1 和 package2 的界限，那么服务端是无法区分 package1 和 package2 的。</li>
<li>情况 3 ：服务端可能会接收到 3 个 package，package1 可能会被拆分为 package1.1 和 package1.2 ，这种现象属于拆包现象。</li>
<li>情况 4 ：服务端接收到 2 个 package，但是这两个 package 都不为完整的，比如 package1 拆分成了 package1.1 和 package1.2 ，但是服务端接收的两个包为 package1.1 和 package1.2 + package2，这种情况是拆包和粘包的综合体。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/6362bfd7-116e-4258-9d81-35ba5e477049"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/6362bfd7-116e-4258-9d81-35ba5e477049" alt="image" style="max-width: 100%;"></a></p>
<p>下面通过两个例子来分别阐述 Netty 中的拆包/粘包现象。</p>
<h3>粘包现象</h3>
<p>从上面图中可以看出，拆包其实就是多个数据包合并成一个。所以我们只需要在客户端发送多个消息给服务端，看服务端是否是接收多次就可以了。</p>
<ul>
<li>服务端代码</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StickyServer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(),
            <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>()).<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">LoggingHandler</span>(<span class="pl-smi">LogLevel</span>.<span class="pl-c1">DEBUG</span>));
                }
            }).<span class="pl-en">bind</span>(<span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>服务端没有多余的代码，只有一个 LoggingHandler 的 ChannelHandler，该 Handler 主要是用于打印服务端的日志情况。</p>
<ul>
<li>客户端代码</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StickyClient</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">Bootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>())
                       .<span class="pl-en">channel</span>(<span class="pl-smi">NioSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">handler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelActive</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>)
                                <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-s1">log</span>.<span class="pl-en">info</span>(<span class="pl-s">"客户端连接成功，开始发送数据"</span>);

                                <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">10</span>; <span class="pl-s1">i</span>++) {
                                    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">byteBuf</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">buffer</span>(<span class="pl-c1">16</span>);
                                    <span class="pl-s1">byteBuf</span>.<span class="pl-en">writeBytes</span>(<span class="pl-k">new</span> <span class="pl-smi">byte</span>[] { <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>,<span class="pl-c1">12</span>, <span class="pl-c1">13</span>, <span class="pl-c1">14</span>, <span class="pl-c1">15</span>});
                                    <span class="pl-s1">ctx</span>.<span class="pl-en">channel</span>().<span class="pl-en">writeAndFlush</span>(<span class="pl-s1">byteBuf</span>);
                                }

                                <span class="pl-s1">log</span>.<span class="pl-en">info</span>(<span class="pl-s">"数据已发送完成"</span>);
                            }
                        });
                }
            }).<span class="pl-en">connect</span>(<span class="pl-s">"127.0.0.1"</span>, <span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>客户端与服务端建立连接后，就向服务端发送 10 次消息，每次 16 byte。</p>
<ul>
<li>服务端日志</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/80c385bc-f79c-434b-a311-b9c3f076050d"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/80c385bc-f79c-434b-a311-b9c3f076050d" alt="image" style="max-width: 100%;"></a></p>
<p>从服务端的运行日志中我们可以看出，客户端虽然发了 10 次，但是服务端只接收了一次，一次 160 byte，充分展示了粘包情况。</p>
<h3>拆包现象</h3>
<p>拆包就和粘包相反，它是将一个数据包拆分为多个数据包。</p>
<ul>
<li>服务端</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UnpackServer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(),
            <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>()).<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">StringDecoder</span>());
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>,
                                <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"服务端接收的内容："</span> +
                                    <span class="pl-s1">msg</span>.<span class="pl-en">toString</span>());
                            }
                        });
                }
            }).<span class="pl-en">bind</span>(<span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>服务端就单纯地将客户端发送过来的消息打印即可。</p>
<ul>
<li>客户端</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UnpackClient</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">Bootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>())
                       .<span class="pl-en">channel</span>(<span class="pl-smi">NioSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">handler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">StringEncoder</span>());
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelActive</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>)
                                <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">500</span>; <span class="pl-s1">i</span>++) {
                                    <span class="pl-s1">ctx</span>.<span class="pl-en">channel</span>()
                                       .<span class="pl-en">writeAndFlush</span>(<span class="pl-s">"大家好，我是大明哥，一个专注[死磕 Java] 的男人!!!<span class="pl-cce">\r</span><span class="pl-cce">\n</span>"</span>);
                                }
                            }
                        });
                }
            }).<span class="pl-en">connect</span>(<span class="pl-s">"127.0.0.1"</span>, <span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>客户端建立连接后，向服务端发送 500 次消息“大家好，我是大明哥，一个专注[死磕 Java] 的男人!!!\r\n”</p>
<ul>
<li>运行结果</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/6a898561-d914-4cc8-87a5-d7fc5db7a7cc"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/6a898561-d914-4cc8-87a5-d7fc5db7a7cc" alt="image" style="max-width: 100%;"></a></p>
<p>运行结果中有一段是乱码，消息也不是完整的，所以这里一定是不完整的，发生了拆包现象。</p>
<h2>为什么会有拆包/粘包</h2>
<p>客户端消息明明是一条一条地发，为什么会有拆包/粘包情况呢？TCP 是传输层协议，它并不了解我们应用层业务数据的含义，它会根据实际情况对数据包进行划分。所以在业务上我们认为是一个完整的数据包，可能会被 TCP 拆分为多个数据库报进行发送，也有可能会将多个数据包合并成一个数据包发送，这就会出现拆包/粘包的问题。</p>
<p>在网络通信的过程中，影响可以发送的数据包大小受很多因素限制，比如 MTU 传输单元大小、MSS 最大报文长度、滑动窗口。同时 TCP 也采用了 Nagle 算法对网络数据包进行了优化，所以要了解 TCP 为什么会有拆包/粘包问题，就需要了解这些概念。</p>
<h3>MTU 最大传输单元</h3>
<blockquote>
<p>MTU（Maximum Transmission Unit），最大传输单元，是指网络能够传输的最大数据包大小，它决定了发送端一次能够发送报文的最大字节数。它是链路层协议，其最大值默认为 1500 byte。</p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/fff7deb6-f87b-4327-86aa-b87bbb3cbe65"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/fff7deb6-f87b-4327-86aa-b87bbb3cbe65" alt="image" style="max-width: 100%;"></a></p>
<p>MTU 是数据链路层对网络层的限制，最小为 46 byte，最大为 1500 byte，意思就是说网络层必须将发给网卡 API 的数据包大小控制在 1500 byte 以下，否则失败。</p>
<p>那为什么要有一个这样的限制呢？我们都知道网络中通常是以数据包为单位进行信息传输的，那么一次传输多大的数据包就决定了整个传输过程中的效率了，理论上数据包的大小设置为尽可能大，因为着有效的数据量就越大，传输的效率也就越高，但是传输一个数据包的延迟就会很大，而且数据包中 bite 位发送错误的概率也就越大，如果这个数据包丢失了，那么重传的代价就会很大。但是如果我们将数据包大小设置较小，那么我们传输的有效数据就会很小，传输效率就会比较低。所以我们就需要 MTU 来控制网络上传输数据包的大小，如果数据包大，我们就将其拆分，如果小，我们就把几个数据包进行合并，从而提供传输效率。</p>
<h3>MSS 最大报文长度</h3>
<blockquote>
<p>MSS（Maximum Segment Size），最大报文长度，它表示 TCP payload 的最大值，它是 TCP 用来限制应用层发送的最大字节数。</p>
</blockquote>
<p>我们知道了 MTU 限定了网络层往数据链路层发送数据包的大小，如果网络层发现一个数据包大于 MTU，那么它需要将其进行分片，切割成小于 MTU 的数据包，再将其发送到数据链路层。</p>
<p>一台主机上的所有应用都将数据包发往网络层，如果这些数据包太大了，则需要对其进行分片，但是这么多数据包都交给网络层来分片，是不是降低了效率？作为网络层，它的理想状态是，让 TCP 来的每一个数据包，大小都小于 MTU，这样它就不需要分片了。</p>
<p>MSS 是 TCP 协议定义的一个选项，是 TCP 用来限定应用层最大的发送字节数。它是在 TCP 连接建立时，双方进行约定的。当一个 TCP 连接建立时，连接的双方都需要通告各自的 MSS，以避免分片。</p>
<p>TCP 建立连接时，双方都需要根据 MTU 来计算各自的 MSS，计算规则如下：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/9184ab63-d4ab-4d4a-8e9d-1a3a5724920f"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/9184ab63-d4ab-4d4a-8e9d-1a3a5724920f" alt="image" style="max-width: 100%;"></a></p>
<p>MTU = IP Header(20) + TCP Header(20) + Data，MTU 默认最大值为 1500，所以 TCP 的有效数据 Data 的最大值为 1500 - 20 - 20 = 1460 ，这个值就是 MSS 的值。</p>
<p>MSS 的值是通过三次握手的方式告知对方的，互相确认对方的 MSS 值大小，取较小的那个作为 MSS。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/ed71cca3-1ac6-4acb-a5d4-946cf1fba460"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/ed71cca3-1ac6-4acb-a5d4-946cf1fba460" alt="image" style="max-width: 100%;"></a></p>
<ol>
<li>客户端在发送的 SYN 报文中携带自己的 MSS（1300）。</li>
<li>服务端接收该报文后，取客户端的 MSS（1300） 和自己本地的 MSS （1200）中较小的那个值作为自己的 MSS（1200）。在回复的 SYN-ACK 中也携带自己的 MSS（1200）。</li>
<li>客户端收到该 SYN-ACK 后，取服务端的 MSS（1200）和自己本地的 MSS（1200）中较小的那个值作为客户端的 MSS（1200）。</li>
</ol>
<h3>Nagle 算法</h3>
<blockquote>
<p><strong>Nagle 算法</strong>于 1984 年被福特航空和通信公司定义为 TCP/IP 拥塞控制方法。它主要用于解决频繁发送小数据包而带来的网络拥塞问题。</p>
</blockquote>
<p>为了尽可能地利用网络带宽，TCP 总是希望能够发送足够大的数据包，由于有 MSS 的控制，所以它总是希望每次都能够以 MSS 的尺寸来发送数据。但是我们需要发送的数据并不会每次都有那么多字节，怎么办？攒着。Nagle 算法会在数据为得到确认之前会先将其写入到缓冲区中，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。</p>
<p><strong>Nagle 算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块。</strong></p>
<p>Nagle 能够有效地降低网络开销，但是它会有一定的延时性，如果我们的业务系统对时延要求比较高的话，希望发出去的消息都能够尽快地响应，这个时候我们就需要关闭 Nagle 算法了。Netty 为了使数据传输延迟最小化，所以就默认禁用了 Nagle 算法。</p>
<p>在 Netty 中可以通过参数 <code class="notranslate">ChannelOption.TCP_NODELAY</code> 来开启和关闭 Nagle 算法。</p>
<h1>Netty 的编解码器</h1>
<h2>拆包/粘包解决方案</h2>
<p>TCP 是面向字节流的协议，它是无法区分数据包界限的。既然底层的 TCP 协议无法区分，那我们就只能在应用层下功夫了 。目前在应用层主流的解决方案有三种：</p>
<ul>
<li>固定长度</li>
</ul>
<p>双方约定一个固定的长度，比如 100 个字节，那么发送端在发送消息时，每个报文都是 100 个字节，不足的补空格或者 0 等其他特殊字符。接收端则每次读取 100 个字节当做一个完整的报文。</p>
<ul>
<li>特殊字符</li>
</ul>
<p>在报文尾部增加一个特殊字符（比如换行符）来作为分割符，接收端接受到消息后可以根据这个分隔符来判断这个消息是否 完整 。</p>
<ul>
<li>消息头携带信息</li>
</ul>
<p>将消息分为消息头和消息体，消息头中包内含消息的长度，接收端获取消息后，从消息头解析出消息的长度，然后向后读取该长度的内容。</p>
<h2>Netty 常用的解码器</h2>
<p>Netty 提供了几种开箱即用的解码器，这些解码器基本覆盖了 TCP 拆包/粘包的通用解决方案。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/1e70e574-a666-4bcd-9480-b63e6a748f19"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/1e70e574-a666-4bcd-9480-b63e6a748f19" alt="image" style="max-width: 100%;"></a></p>
<p>下面我们就来了解这些解码器吧！</p>
<h3>FixedLengthFrameDecoder</h3>
<p>FixedLengthFrameDecoder 为定长解码器，使用起来非常方便，只需要通过构造函数设定一个长度 frameLength 即可。无论发送方怎么发送数据，它都会严格按照设定的长度 frameLength 来解码。下面就来演示下。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">FixedLengthFrameServer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(),
            <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>()).<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">FixedLengthFrameDecoder</span>(<span class="pl-c1">8</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">LoggingHandler</span>(<span class="pl-smi">LogLevel</span>.<span class="pl-c1">DEBUG</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>,
                                <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"接收内容："</span> +
                                    ((<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>).<span class="pl-en">toString</span>(
                                        <span class="pl-smi">Charset</span>.<span class="pl-en">defaultCharset</span>()));
                            }
                        });
                }
            }).<span class="pl-en">bind</span>(<span class="pl-c1">8081</span>);
    }
}</pre></div>
<p><code class="notranslate">new FixedLengthFrameDecoder(8)</code>，固定 8 byte 的解码器。我们通过 telnet 命令向服务端发送数据，发送内容为：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/521692c9-44d2-4d32-9ed6-277df2d6e360"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/521692c9-44d2-4d32-9ed6-277df2d6e360" alt="image" style="max-width: 100%;"></a></p>
<p>服务端响应结果：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/5de74581-8f2f-4799-b146-1ba54f833ee2"><img src="https://github.com/yakun4566/yakun4566.github.io/assets/18443998/5de74581-8f2f-4799-b146-1ba54f833ee2" alt="image" style="max-width: 100%;"></a></p>
<p>绿色部分是每次读取缓冲区的大小，这里可以看出都是 8 byte。第一次发送 <code class="notranslate">1234567890</code>，服务端只读取了 <code class="notranslate">12345678</code>，其中 <code class="notranslate">90\n</code>还保留这，继续发送 <code class="notranslate">12345678</code> ，这个时候够了 8 byte，服务端又读取 <code class="notranslate">90\n1234</code>，<code class="notranslate">5678</code> 保留。</p>
<p>FixedLengthFrameDecoder 的优势就在于使用起来非常简单，也很容易理解，但是缺点就在于，客户端每次发送报文的时候都要补齐 N 位，不够用特殊字符来补齐，是非常浪费空间的，比如定义固定长度为 1024，但是我们发送的数据为 <code class="notranslate">1</code>，客户端在发送这个报文时也需要补齐 1024 位，但是这个时候的有效位只有 1 位，1023 位都是无效数据，太浪费了。</p>
<h3>LineBasedFrameDecoder</h3>
<p>LineBasedFrameDecoder 是基于回车换行符解码器，它能够按照我们输入的回车换行符（ <code class="notranslate">\n</code>or <code class="notranslate">\r\n</code>）对接收到的消息进行解码。</p>
<p>LineBasedFrameDecoder 的构造器接受一个 int 类型的参数 <code class="notranslate">maxLength</code>，用来限制一次最大的解码长度。如果超过 <code class="notranslate">maxLength</code> 还没有检测到回车换行符，就会抛出 <code class="notranslate">TooLongFrameException</code>，可以说 <code class="notranslate">maxLength</code> 是对程序的一种 保护措施。</p>
<p>我们来演示下。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">LineBasedFrameDecoderServer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(),
            <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>()).<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">LineBasedFrameDecoder</span>(<span class="pl-c1">12</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">LoggingHandler</span>(<span class="pl-smi">LogLevel</span>.<span class="pl-c1">DEBUG</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>,
                                <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"接收内容："</span> +
                                    ((<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>).<span class="pl-en">toString</span>(
                                        <span class="pl-smi">Charset</span>.<span class="pl-en">defaultCharset</span>()));
                            }
                        });
                }
            }).<span class="pl-en">bind</span>(<span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>定义 <code class="notranslate">LineBasedFrameDecoder(12)</code>，即解码最大的长度为 12 byte，超过 12 byte 的数据都会丢弃。客户端发送内容为 <code class="notranslate">123\n45678\r90\r\nabcdf\n\rghijkmnopqrst\n</code>，服务端解析结果如下：</p>
<pre class="notranslate"><code class="notranslate">2022-08-09 08:57:29.933 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x13804585, L:/127.0.0.1:8081 - R:/127.0.0.1:57368] READ: 3B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 31 32 33                                        |123             |
+--------+-------------------------------------------------+----------------+
接收内容：123
2022-08-09 08:57:29.934 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x13804585, L:/127.0.0.1:8081 - R:/127.0.0.1:57368] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 34 35 36 37 38 0d 39 30                         |45678.90        |
+--------+-------------------------------------------------+----------------+
90
2022-08-09 08:57:29.934 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x13804585, L:/127.0.0.1:8081 - R:/127.0.0.1:57368] READ: 5B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 62 63 64 66                                  |abcdf           |
+--------+-------------------------------------------------+----------------+
接收内容：abcdf
2022-08-09 08:57:29.935 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x13804585, L:/127.0.0.1:8081 - R:/127.0.0.1:57368] EXCEPTION: io.netty.handler.codec.TooLongFrameException: frame length (14) exceeds the allowed maximum (12)
io.netty.handler.codec.TooLongFrameException: frame length (14) exceeds the allowed maximum (12)
.....

</code></pre>
<p>从结果可以看到：</p>
<ul>
<li>第一次：读取 3 个字节，内容为 <code class="notranslate">123</code>，所以 <code class="notranslate">\n</code> 可以解析。</li>
<li>第二次：读取 8 个字节，内容为 <code class="notranslate">45678.90，</code>所以 <code class="notranslate">\r</code> 无法解析，<code class="notranslate">\r\n</code> 可以解析。</li>
<li>第三次：读取 5 个字节，内容为 <code class="notranslate">abcdf</code></li>
<li>第四次：抛出 TooLongFrameException 异常，因为我们输入的内容为 14 个字节超过了 12 个字节。细心的小伙伴可能会发现 <code class="notranslate">ghijkmnopqrst</code> 不是只有 12 个字节么，怎么会是 14 呢？因为前面还有一个 <code class="notranslate">\r</code></li>
</ul>
<h3>DelimiterBasedFrameDecoder</h3>
<p>DelimiterBasedFrameDecoder 是特殊分隔符解码器，它和 LineBasedFrameDecoder 相似，只不是 LineBasedFrameDecoder 是固定回车换行符为分割符而已。相比 LineBasedFrameDecoder，DelimiterBasedFrameDecoder 更加通用，允许我们指定任何特殊字符作为分割符，而且提供了更加精细的控制。</p>
<p>DelimiterBasedFrameDecoder 提供了多个构造方法以供我们来使用它，但最终都是调用以下构造方法：</p>
<pre class="notranslate"><code class="notranslate">public DelimiterBasedFrameDecoder(
		int maxFrameLength, boolean stripDelimiter, boolean failFast, ByteBuf... delimiters) {
}
</code></pre>
<p>下面我们就来了解这个构造方法每个属性的含义。</p>
<ul>
<li><strong>delimiters</strong></li>
</ul>
<p>delimiters 指定分割符。我们可以指定一个或者多个分割符，如果指定多个，那么 DelimiterBasedFrameDecoder 在解码的时候会选择长度最短的分割符进行消息拆分。</p>
<p>比如</p>
<div class="highlight highlight-source-diff"><pre class="notranslate"><span class="pl-mi1"><span class="pl-mi1">+</span>--------------+ | ABC\nDEF\r\n | +--------------+</span></pre></div>
<p>如果我们指定分隔符为 \n 和 \r\n，那么将会解码出 2 个消息：</p>
<div class="highlight highlight-source-diff"><pre class="notranslate"><span class="pl-mi1"><span class="pl-mi1">+</span>-----+-----+ | ABC | DEF | +-----+-----+</span></pre></div>
<p>如果我们指定分割符为 \r\n，那只会解码出来 1 个消息：</p>
<div class="highlight highlight-source-diff"><pre class="notranslate"><span class="pl-mi1"><span class="pl-mi1">+</span>----------+ | ABC\nDEF | +----------+</span></pre></div>
<ul>
<li><strong>maxLength</strong></li>
</ul>
<p>maxLength 为最大报文长度限制，与 LineBasedFrameDecoder 的 maxLength 属性意义一样：如果超过 maxLength 还没有检测到分割符，就会抛出 TooLongFrameException。</p>
<ul>
<li><strong>failFast</strong></li>
</ul>
<p>failFast 为是否快速失败开关。它与 maxLength 需要搭配使用，通过设置 failFast 可以控制抛出 TooLongFrameException 的时机。如果 failFast = true，那么就会立刻抛出 TooLongFrameException，不再继续解码。如果 failFast = false，那么会 等到解码出这个完整的消息后才会抛出 TooLongFrameException。</p>
<ul>
<li><strong>stripDelimiter</strong></li>
</ul>
<p>用于判断解码后是否需要去掉分割符。如果为 false，那么上面的解码结果为：</p>
<div class="highlight highlight-source-diff"><pre class="notranslate"><span class="pl-mi1"><span class="pl-mi1">+</span>-------+---------+    | ABC\n | DEF\r\n |    +-------+---------+</span></pre></div>
<p>下面我们来小试牛刀。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DelimiterBasedFrameDecoderServer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>().<span class="pl-en">group</span>(<span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(),
            <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>()).<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>).<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {
                <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>)
                    <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">delimiter</span> = <span class="pl-smi">Unpooled</span>.<span class="pl-en">copiedBuffer</span>(<span class="pl-s">"|"</span>.<span class="pl-en">getBytes</span>());
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>()
                      .<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">DelimiterBasedFrameDecoder</span>(<span class="pl-c1">10</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>,
                            <span class="pl-s1">delimiter</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">LoggingHandler</span>(<span class="pl-smi">LogLevel</span>.<span class="pl-c1">DEBUG</span>));
                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInboundHandlerAdapter</span>() {
                            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
                            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>,
                                <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
                                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"接收内容："</span> +
                                    ((<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>).<span class="pl-en">toString</span>(
                                        <span class="pl-smi">Charset</span>.<span class="pl-en">defaultCharset</span>()));
                            }
                        });
                }
            }).<span class="pl-en">bind</span>(<span class="pl-c1">8081</span>);
    }
}</pre></div>
<p>咱们的解码器为： <code class="notranslate">new DelimiterBasedFrameDecoder(10, true, true, delimiter)</code>：</p>
<ul>
<li>分隔符 delimiter：|</li>
<li>最大报文长度 maxLength ：10</li>
<li>是否快速失败 failFast：false</li>
<li>是否去掉分隔符stripDelimiter：false</li>
</ul>
<p>我们发送如下内容：</p>
<pre class="notranslate"><code class="notranslate">hello,|this is|sikejava.com|wula|
</code></pre>
<p>运行结果：</p>
<div class="highlight highlight-source-lua"><pre class="notranslate"><span class="pl-c1">2022</span><span class="pl-k">-</span><span class="pl-c1">08</span><span class="pl-k">-</span><span class="pl-c1">10</span> <span class="pl-c1">21</span>:<span class="pl-c1">53</span>:<span class="pl-c1">50.706</span> [<span class="pl-smi">nioEventLoopGroup</span><span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-smi">DEBUG</span> <span class="pl-smi">io</span>.<span class="pl-e">netty</span>.<span class="pl-e">handler</span>.<span class="pl-e">logging</span>.<span class="pl-e">LoggingHandler</span> <span class="pl-k">-</span> [<span class="pl-en">id</span>: <span class="pl-c1">0x96ae16a6</span>, <span class="pl-en">L</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">8081</span> <span class="pl-k">-</span> <span class="pl-en">R</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">63971</span>] <span class="pl-en">READ</span>: <span class="pl-c1">7</span>B
         <span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>---------------------------------------------+</span>
         |  <span class="pl-c1">0</span>  <span class="pl-c1">1</span>  <span class="pl-c1">2</span>  <span class="pl-c1">3</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>  <span class="pl-c1">6</span>  <span class="pl-c1">7</span>  <span class="pl-c1">8</span>  <span class="pl-c1">9</span>  <span class="pl-smi">a</span>  <span class="pl-smi">b</span>  <span class="pl-smi">c</span>  <span class="pl-smi">d</span>  <span class="pl-smi">e</span>  <span class="pl-smi">f</span> |
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+-------------------------------------------------+----------------+</span>
|<span class="pl-c1">00000000</span>| <span class="pl-c1">68</span> <span class="pl-c1">65</span> <span class="pl-c1">6</span>c <span class="pl-c1">6</span>c <span class="pl-c1">6</span>f <span class="pl-c1">2</span>c <span class="pl-c1">7</span>c                            |<span class="pl-smi">hello</span>,|         |
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+-------------------------------------------------+----------------+</span>
接收内容：<span class="pl-smi">hello</span>,|
<span class="pl-c1">2022</span><span class="pl-k">-</span><span class="pl-c1">08</span><span class="pl-k">-</span><span class="pl-c1">10</span> <span class="pl-c1">21</span>:<span class="pl-c1">53</span>:<span class="pl-c1">50.706</span> [<span class="pl-smi">nioEventLoopGroup</span><span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-smi">DEBUG</span> <span class="pl-smi">io</span>.<span class="pl-e">netty</span>.<span class="pl-e">handler</span>.<span class="pl-e">logging</span>.<span class="pl-e">LoggingHandler</span> <span class="pl-k">-</span> [<span class="pl-en">id</span>: <span class="pl-c1">0x96ae16a6</span>, <span class="pl-en">L</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">8081</span> <span class="pl-k">-</span> <span class="pl-en">R</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">63971</span>] <span class="pl-en">READ</span>: <span class="pl-c1">8</span>B
         <span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>---------------------------------------------+</span>
         |  <span class="pl-c1">0</span>  <span class="pl-c1">1</span>  <span class="pl-c1">2</span>  <span class="pl-c1">3</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>  <span class="pl-c1">6</span>  <span class="pl-c1">7</span>  <span class="pl-c1">8</span>  <span class="pl-c1">9</span>  <span class="pl-smi">a</span>  <span class="pl-smi">b</span>  <span class="pl-smi">c</span>  <span class="pl-smi">d</span>  <span class="pl-smi">e</span>  <span class="pl-smi">f</span> |
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+-------------------------------------------------+----------------+</span>
|<span class="pl-c1">00000000</span>| <span class="pl-c1">74</span> <span class="pl-c1">68</span> <span class="pl-c1">69</span> <span class="pl-c1">73</span> <span class="pl-c1">20</span> <span class="pl-c1">69</span> <span class="pl-c1">73</span> <span class="pl-c1">7</span>c                         |<span class="pl-smi">this</span> <span class="pl-smi">is</span>|        |
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+-------------------------------------------------+----------------+</span>
接收内容：<span class="pl-smi">this</span> <span class="pl-smi">is</span>|
<span class="pl-c1">2022</span><span class="pl-k">-</span><span class="pl-c1">08</span><span class="pl-k">-</span><span class="pl-c1">10</span> <span class="pl-c1">21</span>:<span class="pl-c1">53</span>:<span class="pl-c1">50.707</span> [<span class="pl-smi">nioEventLoopGroup</span><span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-smi">DEBUG</span> <span class="pl-smi">io</span>.<span class="pl-e">netty</span>.<span class="pl-e">handler</span>.<span class="pl-e">logging</span>.<span class="pl-e">LoggingHandler</span> <span class="pl-k">-</span> [<span class="pl-en">id</span>: <span class="pl-c1">0x96ae16a6</span>, <span class="pl-en">L</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">8081</span> <span class="pl-k">-</span> <span class="pl-en">R</span>:<span class="pl-k">/</span><span class="pl-c1">127.0</span>.0.1:<span class="pl-c1">63971</span>] <span class="pl-en">EXCEPTION</span>: <span class="pl-smi">io</span>.<span class="pl-e">netty</span>.<span class="pl-e">handler</span>.<span class="pl-e">codec</span>.<span class="pl-en">TooLongFrameException</span>: <span class="pl-smi">frame</span> <span class="pl-smi">length</span> <span class="pl-smi">exceeds</span> <span class="pl-c1">10</span>: <span class="pl-c1">12</span> <span class="pl-k">-</span> <span class="pl-smi">discarded</span>
<span class="pl-smi">io</span>.<span class="pl-e">netty</span>.<span class="pl-e">handler</span>.<span class="pl-e">codec</span>.<span class="pl-en">TooLongFrameException</span>: <span class="pl-smi">frame</span> <span class="pl-smi">length</span> <span class="pl-smi">exceeds</span> <span class="pl-c1">10</span>: <span class="pl-c1">12</span> <span class="pl-k">-</span> <span class="pl-smi">discarded</span>
</pre></div>
<h3>LengthFieldBasedFrameDecoder</h3>
<p>LengthFieldBasedFrameDecoder 是长度域解码器，它相比前面三个解码器来说复杂多了，当然功能也更加强大了，它是 Netty 中最常用解决拆包/粘包的解码器了。</p>
<p>要掌握 LengthFieldBasedFrameDecoder 必须要理解它的 4 个属性：</p>
<ul>
<li><strong>lengthFieldOffset</strong>：长度字段的偏移量，也就是存放长度数据的起始位置，即接收的字节数组中下标为 lengthFieldOffset 的地方就是长度域的开始地方。</li>
<li><strong>lengthFieldLength</strong>：长度字段所占用的字节数。即接收的字节数组中 <code class="notranslate">bytes[lengthFieldOffset,(lengthFieldOffset + lengthFieldLength)]</code> 就是长度字段。</li>
<li><strong>lengthAdjustment</strong>：消息修正值。在一些复杂的场景中，长度域不仅仅只是单存地包括消息，还包括了版本号、属性类型、数据状态等等，这个时候我们就需要利用 lengthAdjustment 来进行修正。</li>
<li><strong>initialBytesToStrip</strong>：解码后需要跳过的字节数，也就是我们消息内容的起始位置。</li>
</ul>
<p>这 4 个属性说实在话，这样硬看还是很难理解的，Netty LengthFieldBasedFrameDecoder 注释中一共给了 7 种场景，描述的非常详细了，我们把这 7 中场景明白了，就真正理解了这 4 个属性的含义以及如何使用 LengthFieldBasedFrameDecoder 了。</p>
<h4><strong>场景 一：最基本消息长度 + 消息内容</strong></h4>
<div class="highlight highlight-source-lua"><pre class="notranslate"><span class="pl-smi">BEFORE</span> <span class="pl-c1">DECODE</span> (<span class="pl-c1">14</span> <span class="pl-smi">bytes</span>)         <span class="pl-smi">AFTER</span> <span class="pl-c1">DECODE</span> (<span class="pl-c1">14</span> <span class="pl-smi">bytes</span>)

<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+----------------+      +--------+----------------+</span>
| <span class="pl-smi">Length</span> | <span class="pl-smi">Actual</span> <span class="pl-smi">Content</span> |<span class="pl-c"><span class="pl-c">----</span>-&gt;| Length | Actual Content |</span>
| <span class="pl-c1">0x000C</span> | <span class="pl-s"><span class="pl-pds">"</span>HELLO, WORLD<span class="pl-pds">" </span></span>|      | <span class="pl-c1">0x000C</span> | <span class="pl-s"><span class="pl-pds">"</span>HELLO, WORLD<span class="pl-pds">" </span></span>|
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+----------------+      +--------+----------------+</span>
</pre></div>
<p>这个场景是最简单，最基本的，因为解码前后，报文内容没有任何变化，报文只包含消息长度 Length 和消息内容 Actual Content。Length 为 16 进制表示，占 2 Byte，Length 内容为 0x000C = 12，表示 Actual Content 内容占用 12 Byte。所以对应 LengthFieldBasedFrameDecoder 参数为：</p>
<ul>
<li>lengthFieldOffset = 0，因为 Length 字段在报文开始的位置。</li>
<li>lengthFieldLength = 2，0x000C 内容占用 2 B。</li>
<li>lengthAdjustment = 0，Length 字段只包含了 Actual Content 长度，不需要做任何修正。</li>
<li>initialBytesToStrip = 0，解码后的内容依然为 Length + Actual Content，不需要跳过任何字节，为 0。</li>
</ul>
<h4>场景二：解码后内容只保留 Conteng</h4>
<div class="highlight highlight-source-lua"><pre class="notranslate"><span class="pl-smi">BEFORE</span> <span class="pl-c1">DECODE</span> (<span class="pl-c1">14</span> <span class="pl-smi">bytes</span>)         <span class="pl-smi">AFTER</span> <span class="pl-c1">DECODE</span> (<span class="pl-c1">12</span> <span class="pl-smi">bytes</span>)

<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+----------------+      +----------------+</span>
| <span class="pl-smi">Length</span> | <span class="pl-smi">Actual</span> <span class="pl-smi">Content</span> |<span class="pl-c"><span class="pl-c">----</span>-&gt;| Actual Content |</span>
| <span class="pl-c1">0x000C</span> | <span class="pl-s"><span class="pl-pds">"</span>HELLO, WORLD<span class="pl-pds">" </span></span>|      | <span class="pl-s"><span class="pl-pds">"</span>HELLO, WORLD<span class="pl-pds">" </span></span>|
<span class="pl-k">+</span><span class="pl-c"><span class="pl-c">----</span>----+----------------+      +----------------+</span>
</pre></div>
<p>相比场景一，场景二解码后的内容只保留了 Actual Content，其他部分保持不变，所以对应参数如下：</p>
<ul>
<li>lengthFieldOffset = 0，因为 Length 字段在报文开始的位置。</li>
<li>lengthFieldLength = 2，0x000C 内容占用 2 B。</li>
<li>lengthAdjustment = 0，Length 字段只包含了 Actual Content 长度，不需要做任何修正。</li>
<li>initialBytesToStrip = 2，解码后的内容只有 Actual Content，需要跳过 Length，所以为 2</li>
</ul>
<h4>场景三：长度字段包含 Length + Content 的长度</h4>
<pre class="notranslate"><code class="notranslate">BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)

+--------+----------------+      +--------+----------------+
| Length | Actual Content |-----&gt;| Length | Actual Content |
| 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |
+--------+----------------+      +--------+----------------+

</code></pre>
<p>场景三与场景一的区别在于 Length 为 0x000E（14），它包含了长度字段 Length 所占用的字节和 Actual Content 所占用的字节。所以如果我们要得到 Actual Content 的长度就必须要减去 Length 所占用的字节，参数如下：</p>
<ul>
<li>lengthFieldOffset = 0，因为 Length 字段在报文开始的位置。</li>
<li>lengthFieldLength = 2，0x000E 内容占用 2 B。</li>
<li>lengthAdjustment = -2，长度字段 0x000E 为 14 ，需要减去长度字段 Length 所占用的字节才能得到 Content 的长度。</li>
<li>initialBytesToStrip = 0，解码后的内容依然为 Length + Actual Content，不需要跳过任何字节，为 0。</li>
</ul>
<h4>场景四：基于长度字段偏移的解码</h4>
<pre class="notranslate"><code class="notranslate">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)

+----------+----------+----------------+      +----------+----------+----------------+
| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |
|  0xCAFE  | 0x00000C | "HELLO, WORLD" |      |  0xCAFE  | 0x00000C | "HELLO, WORLD" |
+----------+----------+----------------+      +----------+----------+----------------+
</code></pre>
<p>场景四相比前面三个场景它多了一个 Header 1部分，该部分内容 <code class="notranslate">0xCAFE</code> 占用 2 个字节，Length 内容为 <code class="notranslate">0x00000C</code> 占用三个字节，值为 12 ，所以参数如下 ：</p>
<ul>
<li>lengthFieldOffset = 2，Length 的 offset 不再是起始位置了，它需要跳过 Header 1 所占用的 2 字节，所以为 2。</li>
<li>lengthFieldLength = 3，0x00000C 占用 3 字节。</li>
<li>lengthAdjustment = 0，Length 字段只包含有 Content 的长度，不需要做调整，为 0。</li>
<li>initialBytesToStrip = 0，解码后的内容为完整报文，不需要跳过任何字节，为 0。</li>
</ul>
<h4>场景五：长度字段与内容字段不再相邻</h4>
<pre class="notranslate"><code class="notranslate">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)

+----------+----------+----------------+      +----------+----------+----------------+
|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |
| 0x00000C |  0xCAFE  | "HELLO, WORLD" |      | 0x00000C |  0xCAFE  | "HELLO, WORLD" |
+----------+----------+----------------+      +----------+----------+----------------+

</code></pre>
<p>场景五与场景四类似，只不过它的 Length 和 Actual Content 不再相邻，这个时候如果我们要取 Actual Content 的内容就要略过 Header 1 字段，参数如下：</p>
<ul>
<li>lengthFieldOffset = 0，Length 在报文开始位置。</li>
<li>lengthFieldLength = 3，0x00000C 占用 3 字节。</li>
<li>lengthAdjustment = 2，Header 1 + Actual Content 为 14 字节，但是 Length 内容为 12，所以需要加上 lengthAdjustment（2）才能得到 Header 1 + Actual Content 的内容。</li>
<li>initialBytesToStrip = 0，解码后的内容为完整报文，不需要跳过任何字节，为 0。</li>
</ul>
<h4>场景六：<strong>基于长度偏移和长度修正的解码</strong></h4>
<pre class="notranslate"><code class="notranslate">BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)

+------+--------+------+----------------+      +------+----------------+
| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |
| 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
+------+--------+------+----------------+      +------+----------------+

</code></pre>
<p>场景六相比场景五而言，多了一个 HDR1 部分，占用 1 字节，且解码后的内容丢弃了 HDR1 和 Length，所以参数如下：</p>
<ul>
<li>lengthFieldOffset = 1，需要跳过 HDR1部分，占用 1 字节，所以为 1。</li>
<li>lengthFieldLength = 2，0x000C 占用 2 字节。</li>
<li>lengthAdjustment = 1，HDR2 + Actual Content 为 13 字节，所以 Length 字段值（12）需要加上 lengthAdjustment（1）才能得到 HDR2 + Actual Content 的内容。</li>
<li>initialBytesToStrip = 3，解码后的内容跳过了 HDR1 + Length，占用 3 字节，所以为 3。</li>
</ul>
<h4>场景七：<strong>长度字段包含除 Content 外的多个其他字段</strong></h4>
<pre class="notranslate"><code class="notranslate">BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)

+------+--------+------+----------------+      +------+----------------+
| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |
| 0xCA | 0x0010 | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
+------+--------+------+----------------+      +------+----------------+

</code></pre>
<p>场景七与场景六的区别在于 Length 字段记录了整个消息报文的长度，所以如果要得到 HDR2 + Actual Content 的内容，我们需要通过 lengthAdjustment 来调整，所以参数如下：</p>
<ul>
<li>lengthFieldOffset = 1，需要跳过 HDR1部分，占用 1 字节，所以为 1。</li>
<li>lengthFieldLength = 2，0x000C 占用 2 字节。</li>
<li>lengthAdjustment = -3，HDR2 + Actual Content 为 13 字节，但是 Length 字段值为 16 ，需要减去 HDR1 + Length 的字节数（3），才能得到 HDR2 + Actual Content （13）。</li>
<li>initialBytesToStrip = 3，解码后的内容跳过了 HDR1 + Length，占用 3 字节，所以为 3。</li>
</ul>
<p>对于 LengthFieldBasedFrameDecoder 而言，上面 7 中场景已经涵盖了大部分的使用场景了，所以如果对那四个属性的含义还不是很理解的话，多看几遍吧。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://yakun4566.github.io"> 小孩不黑 </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","yakun4566/yakun4566.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>



</html>
